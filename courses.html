<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Courses - Ukno Club</title>
    <link rel="stylesheet" href="courses.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Roboto&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="course-container">
        <header class="course-header">
            <div class="branding">
                <img src="assets/logo.png" alt="Ukno Club" class="logo">
                <h1 id="pageTitle">Loading...</h1> </div>
            <nav class="header-nav">
                <a href="dashboard.html">Dashboard</a>
                <a href="courses.html">Catalog</a>
                <a href="notes.html">My Notes</a>
                <a href="feedback.html">Feedback</a>
                 <a href="auth.html" class="logout-btn" id="logoutBtn">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </a>
            </nav>
        </header>

        <main class="course-main">
            <div id="courseIndexContent">
                 <p id="indexLoadingMessage" class="message-info">Loading course catalog...</p>
                 </div>

            <div id="videoPlayerContent" class="hidden">
                <div class="back-link-container">
                    <a href="courses.html" class="back-link"><i class="fas fa-arrow-left"></i> Back to Catalog</a>
                </div>
                <h2 id="videoTitle"></h2> <div class="video-container">
                    <div id="youtubePlayer"></div>
                </div>
                <p id="resumeMessage" style="color: var(--text-secondary); font-size: 0.9rem; text-align: center; margin-top: 10px; display: none;"></p>

                <div class="notes-section">
                    <h3>Your Notes</h3>
                    <label for="videoNotes"></label>
                    <textarea id="videoNotes" placeholder="Write your notes here..."></textarea>
                     <p id="notesMessage" class="message"></p>
                </div>
            </div>
        </main>

        <script>
            // --- localStorage/sessionStorage Keys (Consistent) ---
            const ADMIN_AUTH_KEY = 'adminAuthenticated';
            const LOGGED_IN_USERNAME_KEY = 'loggedInUsername';


            // --- Authentication Check ---
            // This runs at the very start to protect the page
             const userAuthLocal = localStorage.getItem('userAuthenticated') === 'true';
             const userAuthSession = sessionStorage.getItem('userAuthenticated') === 'true';
             const adminAuthLocal = localStorage.getItem(ADMIN_AUTH_KEY) === 'true';

             console.log("--- Courses.html Auth Check ---");
             console.log("localStorage userAuthenticated:", localStorage.getItem('userAuthenticated'), "->", userAuthLocal);
             console.log("sessionStorage userAuthenticated:", sessionStorage.getItem('userAuthenticated'), "->", userAuthSession);
             console.log("localStorage adminAuthenticated:", localStorage.getItem(ADMIN_AUTH_KEY), "->", adminAuthLocal);


             if (!userAuthLocal && !userAuthSession && !adminAuthLocal) {
                 console.log("Courses: User is NOT authenticated. Redirecting to auth.html");
                 // Optional: Show a message before redirecting
                 // document.body.innerHTML = '<p style="text-align:center; margin-top:50px;">Not authenticated. Redirecting...</p>';
                 window.location.replace("auth.html#login");
                 // Stop script execution if not authenticated
                 throw new Error("Not Authenticated"); // Throw an error to stop further script execution cleanly
             } else {
                  console.log("Courses: User IS authenticated. Proceeding to load courses content.");
                  // Script execution continues within this authenticated block
             }


            // --- YouTube Player API Script ---
            // This code loads the IFrame Player API asynchronously.
            var tag = document.createElement('script');
             tag.src = "https://www.youtube.com/iframe_api"; // Correct API URL
            var firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);


            // --- Global variables for YouTube Player and Current Video ---
            var player;
            let currentVideoTopicId = null;
            let currentVideoDbId = null;


            // --- Helper Function to show messages in a specific element ---
            function showMessage(element, message, type = 'info') {
                if (element) {
                    element.textContent = message;
                    element.className = `message message-${type}`;
                     element.style.display = 'block';
                }
            }

            function clearMessage(element) {
                 if (element) {
                     element.textContent = '';
                     element.className = 'message';
                     element.style.display = 'none';
                 }
            }


            // --- Function called when the YouTube API is ready. ---
            function onYouTubeIframeAPIReady() {
                console.log('YouTube IFrame API is ready');
                 const urlParams = new URLSearchParams(window.location.search);
                 const videoTopicIdInUrl = urlParams.get('video');

                 if (videoTopicIdInUrl) {
                      // If a video ID is in the URL, fetch its details and load the player
                      fetchVideoAndLoadPlayer(videoTopicIdInUrl);
                 } else {
                      // If no video ID, DOMContentLoaded will fetch and render the catalog
                      console.log("No video ID in URL, DOMContentLoaded will handle catalog.");
                 }
            }

            // --- Function to Fetch a Specific Video's Data and Load the Player ---
            async function fetchVideoAndLoadPlayer(topicId) {
                const videoTitleElement = document.getElementById('videoTitle');
                 const videoPlayerContentDiv = document.getElementById('videoPlayerContent');
                 const courseIndexContentDiv = document.getElementById('courseIndexContent');
                 const pageTitleElement = document.getElementById('pageTitle');
                 const loadingMessageElement = document.getElementById('indexLoadingMessage');

                 if (courseIndexContentDiv) courseIndexContentDiv.classList.add('hidden');
                 if (videoPlayerContentDiv) videoPlayerContentDiv.classList.remove('hidden');
                 if (loadingMessageElement) loadingMessageElement.style.display = 'none';


                if (videoTitleElement) videoTitleElement.textContent = "Loading Video...";
                if (pageTitleElement) pageTitleElement.textContent = "Loading Video...";

                console.log('Attempting to fetch video details for topicId:', topicId);

                try {
                     const response = await fetch(`http://127.0.0.1:5000/courses/video/${topicId}`);
                     if (!response.ok) {
                         console.error('Failed to fetch video details:', response.status, response.statusText);
                          if (videoTitleElement) videoTitleElement.textContent = "Error Loading Video";
                          if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                           if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Error loading video details.</p>';
                         return;
                     }
                     const videoDetails = await response.json();
                     console.log('Video details fetched:', videoDetails);

                     if (!videoDetails || !videoDetails.topicId || !videoDetails.videoUrl) {
                          console.error('Fetched video data is incomplete or invalid:', videoDetails);
                           if (videoTitleElement) videoTitleElement.textContent = "Error Loading Video";
                           if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                           if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Fetched video data is incomplete.</p>';
                          return;
                     }

                     currentVideoTopicId = videoDetails.topicId;
                     currentVideoDbId = videoDetails.id;

                     if (videoTitleElement) videoTitleElement.textContent = videoDetails.videoTitle;
                     if (pageTitleElement) pageTitleElement.textContent = videoDetails.videoTitle;


                     let youtubeId = null;
                     let isPlaylist = false;

                      try {
                           const url = new URL(videoDetails.videoUrl);
                           // Corrected YouTube URL check
                           if (url.hostname.includes('youtube.com') || url.hostname.includes('youtu.be') || url.hostname.includes('youtu.be') || url.hostname.includes('youtube.com')) {
                                if (url.searchParams.get('list')) {
                                    isPlaylist = true;
                                    youtubeId = url.searchParams.get('list');
                                     console.log('Detected YouTube playlist ID:', youtubeId);
                                } else if (url.searchParams.get('v')) {
                                    youtubeId = url.searchParams.get('v');
                                     console.log('Detected YouTube video ID:', youtubeId);
                                } else {
                                     // Handle youtu.be/VIDEO_ID or youtu.be format
                                     const pathSegments = url.pathname.split('/').filter(segment => segment);
                                      if (pathSegments.length > 0) {
                                          youtubeId = pathSegments[pathSegments.length - 1];
                                           console.log('Detected youtu.be/youtu.be video ID:', youtubeId);
                                      }
                                }
                           }
                      } catch (e) {
                          console.error("Error parsing video URL:", videoDetails.videoUrl, e);
                           if (videoTitleElement) videoTitleElement.textContent = "Invalid Video URL";
                           if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                           if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">The video URL is invalid.</p>';
                          return;
                      }


                     if (!youtubeId) {
                         console.error('Could not extract YouTube ID from URL:', videoDetails.videoUrl);
                          if (videoTitleElement) videoTitleElement.textContent = "Invalid Video URL";
                          if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                          if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Could not extract YouTube video/playlist ID from the URL.</p>';
                         return;
                     }


                     // --- Load the YouTube Player ---
                      // Only proceed if YT object and youtubePlayer div are available
                      const youtubePlayerDiv = document.getElementById('youtubePlayer');
                     if (typeof YT !== 'undefined' && YT.Player && youtubePlayerDiv) {
                          const playerOptions = {
                              height: '390',
                              width: '640',
                              playerVars: {
                                  'autoplay': 1,
                                  'controls': 1,
                                  'enablejsapi': 1,
                                  'rel': 0,
                                  'showinfo': 0,
                                  'modestbranding': 1,
                                  'playsinline': 1
                              },
                              events: {
                                  'onReady': onPlayerReady,
                                  'onStateChange': onPlayerStateChange,
                              }
                          };

                          if (isPlaylist) {
                              playerOptions.playerVars.listType = 'playlist';
                              playerOptions.playerVars.list = youtubeId;
                          } else {
                              playerOptions.videoId = youtubeId;
                          }

                           // Clear previous player content if any
                           youtubePlayerDiv.innerHTML = '';

                          player = new YT.Player('youtubePlayer', playerOptions);
                          console.log("YouTube Player initiated.");

                      } else {
                            console.error("YouTube API not ready or 'youtubePlayer' element not found!");
                             if (videoPlayerContentDiv) {
                                  videoPlayerContentDiv.innerHTML = '<p class="message message-error">Error initializing video player (API not loaded or HTML element missing).</p>';
                                   if (videoTitleElement) videoTitleElement.textContent = "Player Error";
                                   if (pageTitleElement) pageTitleElement.textContent = "Player Error";
                             }
                      }


                    // --- Fetch and Load Saved Notes ---
                    const loggedInUsername = localStorage.getItem(LOGGED_IN_USERNAME_KEY) || sessionStorage.getItem(LOGGED_IN_USERNAME_KEY);
                    fetchAndLoadNotes(loggedInUsername, currentVideoTopicId);


                    // --- Fetch and Load Saved Progress ---
                     fetchAndLoadProgress(loggedInUsername, currentVideoTopicId);


                 } catch (error) {
                     console.error('An unexpected error occurred while fetching video details:', error);
                      if (videoTitleElement) videoTitleElement.textContent = "Error Loading Video";
                      if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                      if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = `<p class="message message-error">An unexpected error occurred: ${error.message}</p>`;
                 }
            }

            // --- Function to Fetch and Load Saved Notes ---
            async function fetchAndLoadNotes(username, topicId) {
                 const notesTextarea = document.getElementById('videoNotes');
                 const notesMessageElement = document.getElementById('notesMessage');
                 if (!notesTextarea || !notesMessageElement) return;

                 if (!username || !topicId) {
                     console.warn("Cannot fetch notes: Username or topicId is missing.");
                     // showMessage(notesMessageElement, "Login required to view notes.", 'secondary'); // Optional
                     return;
                 }

                 clearMessage(notesMessageElement);
                 showMessage(notesMessageElement, "Loading notes...", 'info');

                 console.log(`Workspaceing notes for user '${username}' and topic_id '${topicId}'`);

                 try {
                     const response = await fetch(`http://127.0.0.1:5000/notes/${username}/${topicId}`);
                     if (!response.ok) {
                         console.error('Failed to fetch notes:', response.status, response.statusText);
                          showMessage(notesMessageElement, `Error loading notes: ${response.statusText}`, 'error');
                         return;
                     }
                     const notesData = await response.json();
                     console.log('Notes data fetched:', notesData);

                     clearMessage(notesMessageElement);

                     if (notesData && notesData.noteContent !== undefined) {
                          notesTextarea.value = notesData.noteContent;
                          console.log("Notes textarea populated.");
                          // Optional: show timestamp if needed
                     } else {
                          notesTextarea.value = '';
                          console.log("No note found for this video.");
                     }

                 } catch (error) {
                     console.error('Error fetching or processing notes data:', error);
                      showMessage(notesMessageElement, `An unexpected error occurred while loading notes: ${error.message}`, 'error');
                 }
            }

            // --- Function to Save Notes ---
             async function saveNotes(username, topicId, noteContent) {
                 const notesMessageElement = document.getElementById('notesMessage');
                  if (!notesMessageElement) return;

                 if (!username || !topicId) {
                     console.warn("Cannot save notes: Username or topicId is missing.");
                      showMessage(notesMessageElement, "Login required to save notes.", 'secondary');
                     return;
                 }

                 clearMessage(notesMessageElement);
                 showMessage(notesMessageElement, "Saving notes...", 'info');

                 console.log(`Attempting to save notes for user '${username}' and topic_id '${topicId}'`);

                 try {
                      const response = await fetch(`http://127.0.0.1:5000/notes/save/${username}/${topicId}`, {
                           method: 'POST',
                           headers: {
                               'Content-Type': 'application/json',
                           },
                           body: JSON.stringify({ noteContent: noteContent }),
                       });

                       if (!response.ok) {
                            console.error('Failed to save notes:', response.status, response.statusText);
                           const errorData = await response.json().catch(() => ({ message: `Error saving notes: ${response.statusText}` }));
                           showMessage(notesMessageElement, errorData.message, 'error');
                            return;
                       }

                       const successData = await response.json();
                       console.log('Notes save success:', successData);
                       showMessage(notesMessageElement, successData.message || 'Notes saved successfully!', 'success');

                       setTimeout(() => { clearMessage(notesMessageElement); }, 3000);

                 } catch (error) {
                      console.error('Error during notes save fetch:', error);
                       showMessage(notesMessageElement, `An unexpected error occurred while saving notes: ${error.message}`, 'error');
                 }
             }


            // --- Function to Fetch and Load Saved Progress ---
             async function fetchAndLoadProgress(username, topicId) {
                 const resumeMessageElement = document.getElementById('resumeMessage');
                 if (!resumeMessageElement) return;

                 if (!username || !topicId) {
                     console.warn("Cannot fetch progress: Username or topicId is missing.");
                     return;
                 }

                 console.log(`Workspaceing progress for user '${username}' and topic_id '${topicId}'`);

                 try {
                     // Assuming the backend endpoint exists and returns { lastWatchedTime: ..., completed: ..., lastUpdated: ... }
                     const response = await fetch(`http://127.0.0.1:5000/progress/${username}/${topicId}`);
                     if (!response.ok) {
                          // This is expected if no progress exists, backend should ideally return 404 or 200 with empty data
                          console.log('Backend progress fetch failed:', response.status, response.statusText, ' - This might be okay if no progress exists.');
                          // No need to show an error message for expected cases like 404
                         return; // Stop if fetch fails or returns non-200/non-404
                     }
                     const progressData = await response.json();
                     console.log('Progress data fetched:', progressData);

                     // Check if progress data is valid and not completed, and player is ready
                     if (progressData && progressData.lastWatchedTime !== undefined && progressData.lastWatchedTime > 0 && !progressData.completed) {
                         const timeToSeek = progressData.lastWatchedTime;
                         const lastUpdatedTimestamp = progressData.lastUpdated;

                          // Wait for player to be ready before seeking
                          function seekWhenReady() {
                               if (player && player.seekTo && typeof player.seekTo === 'function') {
                                   player.seekTo(timeToSeek);
                                   console.log('Resuming video to:', timeToSeek, 'seconds after player ready');

                                    const minutes = Math.floor(timeToSeek / 60);
                                    const seconds = Math.floor(timeToSeek % 60);
                                    const timestamp = lastUpdatedTimestamp ? new Date(lastUpdatedTimestamp).toLocaleString() : 'unknown date';

                                    showMessage(resumeMessageElement, `Resuming from ${minutes}m ${seconds}s (Last viewed: ${timestamp})`, 'info');
                                    setTimeout(() => { clearMessage(resumeMessageElement); }, 8000);
                               } else {
                                   console.log("Player not yet ready, waiting to seek...");
                                    // Wait a bit longer and try again
                                    setTimeout(seekWhenReady, 100);
                               }
                           }

                          seekWhenReady(); // Start the waiting/seeking process


                     } else {
                         console.log("No valid progress data found to resume from, or video already completed.");
                     }

                 } catch (error) {
                     console.error('Error fetching or processing progress data:', error);
                     // showMessage(resumeMessageElement, `An unexpected error occurred while loading progress: ${error.message}`, 'error'); // Optional
                 }
            }


            // --- Function to Save User Video Progress (Current Time) ---
             async function saveProgress(username, topicId, currentTime) {
                 if (!username || !topicId || currentTime === undefined) {
                     console.warn("Cannot save progress: Username, topicId, or current time is missing.");
                     return;
                 }

                 // console.log(`Saving progress for user '${username}', topic_id '${topicId}': ${currentTime}s`);

                  const saveUrl = `http://127.0.0.1:5000/progress/save/${username}/${topicId}`;
                  const progressData = { currentTime: currentTime };

                  try {
                       const response = await fetch(saveUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(progressData),
                        });

                        if (!response.ok) {
                            console.error('Failed to save progress:', response.status, response.statusText);
                        } else {
                             // console.log('Progress saved successfully.');
                        }
                   } catch (error) {
                        console.error('Error during save progress fetch:', error);
                   }
             }

            // --- Function to Mark Video as Completed ---
             async function markVideoAsCompleted(username, topicId) {
                 if (!username || !topicId) {
                     console.warn("Cannot mark video as completed: Username or topicId is missing.");
                     return;
                 }
                 console.log(`Marking video ${topicId} as completed for user ${username}.`);

                 const completeUrl = `http://127.0.0.1:5000/progress/complete/${username}/${topicId}`;

                 try {
                      const response = await fetch(completeUrl, {
                           method: 'POST',
                           headers: {
                               'Content-Type': 'application/json',
                           },
                       });

                       if (!response.ok) {
                           console.error('Failed to mark video as completed:', response.status, response.statusText);
                       } else {
                            const successData = await response.json().catch(() => ({ message: 'Completed successfully (no message from backend)'}));
                            console.log('Video marked completed successfully:', successData.message);
                       }
                 } catch (error) {
                      console.error('Error during mark completed fetch:', error);
                 }
             }


            // --- YouTube Player API Event Handlers ---

            // The API calls this function when the video player is ready.
            function onPlayerReady(event) {
                 console.log('YouTube Player is ready');
                 // fetchAndLoadProgress will attempt to seek here if player was ready.
                 // If not ready when fetch finished, fetchAndLoadProgress has a retry loop.
            }

            // The API calls this function when the player's state changes.
            function onPlayerStateChange(event) {
                 const loggedInUsername = localStorage.getItem(LOGGED_IN_USERNAME_KEY) || sessionStorage.getItem(LOGGED_IN_USERNAME_KEY);
                 if (!loggedInUsername || loggedInUsername === 'Guest' || !currentVideoTopicId) {
                     return;
                 }

                 if (event.data === YT.PlayerState.PLAYING || event.data === YT.PlayerState.PAUSED) {
                     const currentTime = player.getCurrentTime();
                     // Save progress after a short delay when playing/paused
                      // Clear any existing timer to avoid saving too often
                      if (window.saveProgressTimer) {
                           clearTimeout(window.saveProgressTimer);
                       }
                       window.saveProgressTimer = setTimeout(() => {
                            saveProgress(loggedInUsername, currentVideoTopicId, currentTime);
                       }, 2000); // Save every 2 seconds while playing/paused (or shortly after state change)


                 } else if (event.data === YT.PlayerState.ENDED) {
                     console.log('Video ended.');
                      // Ensure any pending progress save timer is cleared
                     if (window.saveProgressTimer) {
                          clearTimeout(window.saveProgressTimer);
                      }
                     const currentTime = player.getCurrentTime();
                     markVideoAsCompleted(loggedInUsername, currentVideoTopicId);
                     // Save final time after completion
                     saveProgress(loggedInUsername, currentVideoTopicId, currentTime);


                     const resumeMessageElement = document.getElementById('resumeMessage');
                     if (resumeMessageElement) {
                         clearMessage(resumeMessageElement);
                     }
                 }
            }


            // --- Event Listener for Note Saving (Auto-save while typing) ---
             document.addEventListener('DOMContentLoaded', function() {
                  const notesTextarea = document.getElementById('videoNotes');
                   const loggedInUsername = localStorage.getItem(LOGGED_IN_USERNAME_KEY) || sessionStorage.getItem(LOGGED_IN_USERNAME_KEY);

                   if (notesTextarea) {
                       let saveNotesTimer = null;
                       notesTextarea.addEventListener('input', function() {
                           clearTimeout(saveNotesTimer);
                           saveNotesTimer = setTimeout(() => {
                                const noteContent = notesTextarea.value;
                                saveNotes(loggedInUsername, currentVideoTopicId, noteContent); // Use global currentVideoTopicId
                           }, 1000);
                       });
                   }


                   // --- Handle Logout Click ---
                   const logoutBtnElement = document.getElementById('logoutBtn');
                   if (logoutBtnElement) {
                       logoutBtnElement.addEventListener('click', function(e) {
                           e.preventDefault();
                           console.log("Logging out...");
                           localStorage.removeItem('userAuthenticated');
                           sessionStorage.removeItem('userAuthenticated');
                           localStorage.removeItem('adminAuthenticated');
                           localStorage.removeItem('loggedInUsername');
                           sessionStorage.removeItem('loggedInUsername');

                           window.location.replace("auth.html");
                       });
                   }

                   // --- Initial Page Load Logic (Catalog vs Player) ---
                    const urlParams = new URLSearchParams(window.location.search);
                    const videoTopicIdInUrl = urlParams.get('video');

                    const courseIndexContent = document.getElementById('courseIndexContent');
                    const videoPlayerContent = document.getElementById('videoPlayerContent');
                    const pageTitle = document.getElementById('pageTitle');
                    const indexLoadingMessage = document.getElementById('indexLoadingMessage');


                    if (videoTopicIdInUrl) {
                        console.log(`Video ID "${videoTopicIdInUrl}" found in URL. Switching to player view.`);
                        // Initial state setup
                        if (courseIndexContent) courseIndexContent.classList.add('hidden');
                        if (videoPlayerContent) videoPlayerContent.classList.remove('hidden');
                         if (pageTitle) pageTitle.textContent = "Loading Video...";
                         if (indexLoadingMessage) indexLoadingMessage.style.display = 'none';

                         // fetchVideoAndLoadPlayer will be called by onYouTubeIframeAPIReady

                    } else {
                        console.log("No video ID in URL. Displaying course catalog.");
                         if (pageTitle) pageTitle.textContent = "Course Catalog";
                         if (videoPlayerContent) videoPlayerContent.classList.add('hidden');
                         if (courseIndexContent) courseIndexContent.classList.remove('hidden');

                        // Fetch all videos and render the index
                         fetchAllVideosAndRenderIndex();
                    }

             }); // End of DOMContentLoaded


            // --- Function to Fetch All Videos and Render the Course Index ---
            async function fetchAllVideosAndRenderIndex() {
                const courseIndexContentDiv = document.getElementById('courseIndexContent');
                 const indexLoadingMessageElement = document.getElementById('indexLoadingMessage');
                 if (!courseIndexContentDiv || !indexLoadingMessageElement) return;

                 clearMessage(indexLoadingMessageElement);
                 showMessage(indexLoadingMessageElement, "Loading course catalog...", 'info');

                 console.log("Fetching all videos from backend for catalog.");

                 try {
                     const response = await fetch(`http://127.0.0.1:5000/courses/all`);
                     if (!response.ok) {
                         console.error('Failed to fetch all videos:', response.status, response.statusText);
                          showMessage(indexLoadingMessageElement, `Error loading courses: ${response.statusText}`, 'error');
                         return;
                     }
                     const videosData = await response.json();
                     console.log('All videos data fetched:', videosData);

                     clearMessage(indexLoadingMessageElement);

                     if (!Array.isArray(videosData) || videosData.length === 0) {
                          showMessage(courseIndexContentDiv, 'No courses or videos available yet. Admin needs to add them.', 'secondary');
                          console.log("No video data received or data is not an array.");
                          return;
                     }

                     renderCourseIndex(videosData);


                 } catch (error) {
                     console.error('Error fetching or processing all videos data:', error);
                      showMessage(indexLoadingMessageElement, `An unexpected error occurred while loading courses: ${error.message}`, 'error');
                 }
             }

             // --- Function to Render the Course Index from Video Data Array ---
             function renderCourseIndex(videosData) {
                  const courseIndexContentDiv = document.getElementById('courseIndexContent');
                  if (!courseIndexContentDiv) return;

                 courseIndexContentDiv.innerHTML = '';

                 if (videosData.length === 0) {
                      showMessage(courseIndexContentDiv, 'No courses or videos available to render.', 'secondary');
                     return;
                 }

                 const modules = {};
                 videosData.forEach(video => {
                      const moduleName = video.videoModule || 'Uncategorized';
                      if (!modules[moduleName]) {
                           modules[moduleName] = [];
                       }
                       modules[moduleName].push(video);
                   });

                  const moduleTitles = {
                       'Statistics': 'ðŸ“Š Statistics Fundamentals',
                       'Excel': 'ðŸ“ˆ Excel for Data Analysis',
                       'SQL': 'ðŸ—„ï¸ SQL for Analytics',
                      'data-analyst': 'ðŸŸ¦ MODULE 1: Data Analyst Track',
                      'business-analyst': 'ðŸŸ¨ MODULE 2: Business Analyst Track',
                      'data-scientist': 'ðŸŸ¥ MODULE 3: Data Scientist Track',
                      'big-data': 'ðŸŸ© BONUS MODULE: Big Data & Cloud Tools',
                      'Uncategorized': 'â“ Uncategorized Videos',
                   };

                 const moduleKeys = Object.keys(modules).sort();

                 if (moduleKeys.length === 0) {
                      showMessage(courseIndexContentDiv, 'No course modules defined in data. Videos might be missing module names.', 'secondary');
                      return;
                   }


                 moduleKeys.forEach(moduleKey => {
                     const moduleVideos = modules[moduleKey];
                     moduleVideos.sort((a, b) => a.videoTitle.localeCompare(b.videoTitle));

                     const moduleSection = document.createElement('section');
                     moduleSection.classList.add('course-module');

                      const fullModuleTitle = moduleTitles[moduleKey] || `ðŸ“š ${moduleKey}`;


                     moduleSection.innerHTML = `
                         <h2>${fullModuleTitle}</h2>
                         <p class="module-goal">Browse videos in this module.</p>
                         <div class="topic-list-grid">
                         </div>
                     `;

                     const topicListGrid = moduleSection.querySelector('.topic-list-grid');

                     moduleVideos.forEach(video => {
                         const topicCardLink = document.createElement('a');
                         topicCardLink.href = `courses.html?video=${video.topicId}`;
                         topicCardLink.classList.add('topic-card');

                         topicCardLink.innerHTML = `
                             <h4>${video.videoTitle}</h4>
                             <p>${video.videoDescription || 'No description available.'}</p>
                             <span class="view-video-link"><i class="fas fa-video"></i> Watch ${video.videoUrl && video.videoUrl.includes('list=') ? 'Playlist' : 'Video'}</span>
                         `;
                         topicListGrid.appendChild(topicCardLink);
                     });

                     courseIndexContentDiv.appendChild(moduleSection);
                 });

                 const comingSoonMessage = document.createElement('p');
                 comingSoonMessage.classList.add('coming-soon');
                 comingSoonMessage.textContent = 'ðŸš§ More categories and videos coming soon...';
                 courseIndexContentDiv.appendChild(comingSoonMessage);

             }


        </script>

    </body>
    </html>