<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Courses - Ukno Club</title>
    <link rel="stylesheet" href="courses.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Roboto&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="course-container">
        <header class="course-header">
            <div class="branding">
                <img src="assets/logo.png" alt="Ukno Club" class="logo">
                <h1 id="pageTitle">Loading...</h1> </div>
            <nav class="header-nav">
                <a href="dashboard.html">Dashboard</a>
                <a href="courses.html">Catalog</a>
                <a href="notes.html">My Notes</a>
                <a href="feedback.html">Feedback</a>
                 <a href="auth.html" class="logout-btn" id="logoutBtn">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </a>
            </nav>
        </header>

        <main class="course-main">
            <div id="courseIndexContent">
                 <p id="indexLoadingMessage" class="message-info">Loading course catalog...</p>
                 </div>

            <div id="videoPlayerContent" class="hidden">
                <div class="back-link-container">
                    <a href="courses.html" class="back-link"><i class="fas fa-arrow-left"></i> Back to Catalog</a>
                </div>
                <h2 id="videoTitle"></h2> <div class="video-container">
                    <div id="youtubePlayer"></div>
                </div>
                <p id="resumeMessage" style="color: var(--text-secondary); font-size: 0.9rem; text-align: center; margin-top: 10px; display: none;"></p>
                 <div class="notes-section">
                    <h3>Your Notes</h3>
                    <label for="videoNotes"></label> <textarea id="videoNotes" placeholder="Write your notes here..."></textarea>
                     <p id="notesMessage" class="message"></p> </div>
            </div>
        </main>

        <script>
            // --- localStorage/sessionStorage Keys (Consistent) ---
            const ADMIN_AUTH_KEY = 'adminAuthenticated';
            const LOGGED_IN_USERNAME_KEY = 'loggedInUsername';


            // --- YouTube Player API Script ---
            // This code loads the IFrame Player API asynchronously.
            var tag = document.createElement('script');
             tag.src = "https://www.youtube.com/iframe_api"; // Correct API URL
            var firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);


            // --- Global variables for YouTube Player and Current Video ---
            var player;
            let currentVideoTopicId = null; // To keep track of the currently loaded video topic ID
            let currentVideoDbId = null; // To store the database ID of the current video


            // --- Helper Function to show messages in a specific element ---
            function showMessage(element, message, type = 'info') {
                if (element) {
                    element.textContent = message;
                    element.className = `message message-${type}`; // Use message class + type class
                     element.style.display = 'block'; // Ensure it's visible
                }
            }

             // --- Helper Function to clear messages in a specific element ---
            function clearMessage(element) {
                 if (element) {
                     element.textContent = '';
                     element.className = 'message';
                     element.style.display = 'none'; // Hide the message element
                 }
             }


            // --- Function called when the YouTube API is ready. ---
            function onYouTubeIframeAPIReady() {
                console.log('YouTube IFrame API is ready');
                 const urlParams = new URLSearchParams(window.location.search);
                 const videoTopicIdInUrl = urlParams.get('video');

                 if (videoTopicIdInUrl) {
                      // If a video ID is in the URL, fetch its details and load the player
                      fetchVideoAndLoadPlayer(videoTopicIdInUrl);
                 } else {
                      // If no video ID, the DOMContentLoaded handler will fetch and render the catalog
                      console.log("No video ID in URL, waiting for DOMContentLoaded to render catalog.");
                 }
            }

            // --- Function to Fetch a Specific Video's Data and Load the Player ---
            async function fetchVideoAndLoadPlayer(topicId) {
                const videoTitleElement = document.getElementById('videoTitle');
                 const videoPlayerContentDiv = document.getElementById('videoPlayerContent');
                 const courseIndexContentDiv = document.getElementById('courseIndexContent');
                 const pageTitleElement = document.getElementById('pageTitle');
                 const loadingMessageElement = document.getElementById('indexLoadingMessage'); // Use the catalog loading message

                 // Ensure video player content is visible and index is hidden
                 if (courseIndexContentDiv) courseIndexContentDiv.classList.add('hidden');
                 if (videoPlayerContentDiv) videoPlayerContentDiv.classList.remove('hidden');
                 if (loadingMessageElement) loadingMessageElement.style.display = 'none'; // Hide catalog loading message


                if (videoTitleElement) videoTitleElement.textContent = "Loading Video...";
                if (pageTitleElement) pageTitleElement.textContent = "Loading Video...";

                console.log('Attempting to fetch video details for topicId:', topicId);

                try {
                     const response = await fetch(`http://127.0.0.1:5000/courses/video/${topicId}`);
                     if (!response.ok) {
                         console.error('Failed to fetch video details:', response.status, response.statusText);
                          if (videoTitleElement) videoTitleElement.textContent = "Error Loading Video";
                          if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                           if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Error loading video details.</p>';
                         return; // Stop if fetch fails
                     }
                     const videoDetails = await response.json();
                     console.log('Video details fetched:', videoDetails);

                     // Check if the response contains valid video data
                     if (!videoDetails || !videoDetails.topicId || !videoDetails.videoUrl) {
                          console.error('Fetched video data is incomplete or invalid:', videoDetails);
                           if (videoTitleElement) videoTitleElement.textContent = "Error Loading Video";
                           if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                           if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Fetched video data is incomplete.</p>';
                          return;
                     }

                     currentVideoTopicId = videoDetails.topicId; // Store topic ID
                     currentVideoDbId = videoDetails.id; // Store database ID (useful for progress/notes API)

                     if (videoTitleElement) videoTitleElement.textContent = videoDetails.videoTitle; // Set the video title
                     if (pageTitleElement) pageTitleElement.textContent = videoDetails.videoTitle; // Update page title


                     // Extract YouTube ID from the URL (assuming it's a standard YouTube URL)
                      let youtubeId = null;
                      let isPlaylist = false;

                      try {
                           const url = new URL(videoDetails.videoUrl);
                           if (url.hostname.includes('youtube.com') || url.hostname.includes('youtu.be')) {
                                if (url.searchParams.get('list')) {
                                    isPlaylist = true;
                                    youtubeId = url.searchParams.get('list'); // Get playlist ID
                                     console.log('Detected YouTube playlist ID:', youtubeId);
                                } else if (url.searchParams.get('v')) {
                                    youtubeId = url.searchParams.get('v'); // Get video ID from 'v' parameter
                                     console.log('Detected YouTube video ID:', youtubeId);
                                } else {
                                     // Handle youtu.be/VIDEO_ID format
                                     const pathSegments = url.pathname.split('/').filter(segment => segment);
                                      if (pathSegments.length > 0) {
                                          youtubeId = pathSegments[pathSegments.length - 1];
                                           console.log('Detected youtu.be video ID:', youtubeId);
                                      }
                                }
                           }
                      } catch (e) {
                          console.error("Error parsing video URL:", videoDetails.videoUrl, e);
                           if (videoTitleElement) videoTitleElement.textContent = "Invalid Video URL";
                           if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                           if (videoPlayerContentDiv) videoPlayerContentContent.innerHTML = '<p class="message message-error">The video URL is invalid.</p>';
                          return;
                      }


                     if (!youtubeId) {
                         console.error('Could not extract YouTube ID from URL:', videoDetails.videoUrl);
                          if (videoTitleElement) videoTitleElement.textContent = "Invalid Video URL";
                          if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                          if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Could not extract YouTube video/playlist ID from the URL.</p>';
                         return;
                     }


                     // --- Load the YouTube Player ---
                     const playerOptions = {
                         height: '390',
                         width: '640',
                         playerVars: {
                             'autoplay': 1, // Optional: Autoplay the video
                             'controls': 1,
                             'enablejsapi': 1,
                             'rel': 0, // Hide related videos
                             'showinfo': 0, // Hide video title and uploader info
                             'modestbranding': 1,
                             'playsinline': 1
                         },
                         events: {
                             'onReady': onPlayerReady,
                             'onStateChange': onPlayerStateChange,
                             // Optional: Listen for playlist events if needed
                             // 'onPlaylistNext': onPlaylistNext,
                             // 'onPlaylistLoaded': onPlaylistLoaded
                         }
                     };

                     if (isPlaylist) {
                         playerOptions.playerVars.listType = 'playlist';
                         playerOptions.playerVars.list = youtubeId;
                         // Optional: Start with a specific video in the playlist
                         // playerOptions.playerVars.index = INDEX_NUMBER;
                     } else {
                         playerOptions.videoId = youtubeId;
                     }

                     // Create the YouTube Player
                     // Ensure the 'youtubePlayer' div exists in your HTML
                     const youtubePlayerDiv = document.getElementById('youtubePlayer');
                      if (youtubePlayerDiv) {
                          player = new YT.Player('youtubePlayer', playerOptions);
                          console.log("YouTube Player initiated.");
                      } else {
                           console.error("HTML element with id 'youtubePlayer' not found!");
                            if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Error initializing video player (HTML element missing).</p>';
                      }


                    // --- Fetch and Load Saved Notes ---
                    fetchAndLoadNotes(loggedInUsername, currentVideoTopicId); // Use topic ID


                    // --- Fetch and Load Saved Progress ---
                    // You might fetch specific progress for this video here,
                    // or rely on the continue learning endpoint's data if you stored it on dashboard load.
                    // A dedicated endpoint like GET /progress/<username>/<topic_id> would be ideal.
                    // For now, let's assume the continue learning endpoint is sufficient to get the last time.
                    // However, fetching the full progress object (completed, time) is better.
                    // Let's add a GET endpoint for single video progress to backend.
                    // Assuming a new backend endpoint: GET /progress/<username>/<topic_id>
                    fetchAndLoadProgress(loggedInUsername, currentVideoTopicId);


                 } catch (error) {
                     console.error('An unexpected error occurred while fetching video details:', error);
                      if (videoTitleElement) videoTitleElement.textContent = "Error Loading Video";
                      if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                      if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = `<p class="message message-error">An unexpected error occurred: ${error.message}</p>`;
                 }
            }

            // --- Function to Fetch and Load Saved Notes ---
            async function fetchAndLoadNotes(username, topicId) {
                 const notesTextarea = document.getElementById('videoNotes');
                 const notesMessageElement = document.getElementById('notesMessage');
                 if (!notesTextarea || !notesMessageElement) return; // Elements not found

                 if (!username || !topicId) {
                     console.warn("Cannot fetch notes: Username or topicId is missing.");
                     showMessage(notesMessageElement, "Cannot load notes (Login required).", 'secondary');
                     return;
                 }

                 clearMessage(notesMessageElement); // Clear previous messages
                 showMessage(notesMessageElement, "Loading notes...", 'info');

                 console.log(`Workspaceing notes for user '${username}' and topic_id '${topicId}'`);

                 try {
                     const response = await fetch(`http://127.0.0.1:5000/notes/${username}/${topicId}`);
                     if (!response.ok) {
                         console.error('Failed to fetch notes:', response.status, response.statusText);
                          showMessage(notesMessageElement, `Error loading notes: ${response.statusText}`, 'error');
                         return;
                     }
                     const notesData = await response.json();
                     console.log('Notes data fetched:', notesData);

                     clearMessage(notesMessageElement); // Clear loading message

                     if (notesData && notesData.noteContent !== undefined) {
                          // If a note was found, populate the textarea
                          notesTextarea.value = notesData.noteContent;
                          console.log("Notes textarea populated.");
                          // Optionally show a timestamp: showMessage(notesMessageElement, `Last saved: ${new Date(notesData.timestamp).toLocaleString()}`, 'info');
                     } else {
                         // No note found (backend returned 200 with message or empty content)
                          notesTextarea.value = ''; // Ensure textarea is empty
                          console.log("No note found for this video.");
                          // showMessage(notesMessageElement, "No notes saved yet.", 'secondary'); // Optional message
                     }

                 } catch (error) {
                     console.error('Error fetching or processing notes data:', error);
                      showMessage(notesMessageElement, `An unexpected error occurred while loading notes: ${error.message}`, 'error');
                 }
            }

            // --- Function to Save Notes ---
             async function saveNotes(username, topicId, noteContent) {
                 const notesMessageElement = document.getElementById('notesMessage');
                  if (!notesMessageElement) return; // Element not found

                 if (!username || !topicId) {
                     console.warn("Cannot save notes: Username or topicId is missing.");
                      showMessage(notesMessageElement, "Cannot save notes (Login required).", 'secondary');
                     return;
                 }

                 clearMessage(notesMessageElement); // Clear previous messages
                 showMessage(notesMessageElement, "Saving notes...", 'info');

                 console.log(`Attempting to save notes for user '${username}' and topic_id '${topicId}'`);

                 try {
                      const response = await fetch(`http://127.0.0.1:5000/notes/save/${username}/${topicId}`, {
                           method: 'POST',
                           headers: {
                               'Content-Type': 'application/json',
                           },
                           body: JSON.stringify({ noteContent: noteContent }),
                       });

                       if (!response.ok) {
                            console.error('Failed to save notes:', response.status, response.statusText);
                            // Attempt to read backend error message
                           const errorData = await response.json().catch(() => ({ message: `Error saving notes: ${response.statusText}` }));
                           showMessage(notesMessageElement, errorData.message, 'error');
                            return; // Stop if save fails
                       }

                       const successData = await response.json(); // Backend returns success message
                       console.log('Notes save success:', successData);
                       showMessage(notesMessageElement, successData.message || 'Notes saved successfully!', 'success');

                       // Optionally clear the success message after a delay
                       setTimeout(() => { clearMessage(notesMessageElement); }, 3000);

                 } catch (error) {
                      console.error('Error during notes save fetch:', error);
                       showMessage(notesMessageElement, `An unexpected error occurred while saving notes: ${error.message}`, 'error');
                 }
             }


            // --- Function to Fetch and Load Saved Progress ---
            // This assumes a backend endpoint GET /progress/<username>/<topic_id> exists
            async function fetchAndLoadProgress(username, topicId) {
                 const resumeMessageElement = document.getElementById('resumeMessage');
                 if (!resumeMessageElement) return; // Element not found

                 if (!username || !topicId) {
                     console.warn("Cannot fetch progress: Username or topicId is missing.");
                     return; // Don't fetch for guests or if video ID is missing
                 }

                 console.log(`Workspaceing progress for user '${username}' and topic_id '${topicId}'`);

                 try {
                     const response = await fetch(`http://127.0.0.1:5000/progress/${username}/${topicId}`); // Assuming this endpoint exists
                     if (!response.ok) {
                         console.warn('Backend progress fetch failed (might be okay if no progress yet):', response.status, response.statusText);
                          // Don't show an error message on the page for expected 404 (no progress)
                          if (response.status === 404) {
                               console.log("No existing progress found (404).");
                          } else {
                               console.error('Failed to fetch progress with unexpected status:', response.status);
                                // Show an error message if status is unexpected
                                // showMessage(resumeMessageElement, `Error loading progress: ${response.statusText}`, 'error'); // Optional
                          }
                         return; // Stop if fetch fails or returns 404
                     }
                     const progressData = await response.json();
                     console.log('Progress data fetched:', progressData);

                     // Check if progress data is valid and not completed
                     if (progressData && progressData.lastWatchedTime !== undefined && progressData.lastWatchedTime > 0 && !progressData.completed) {
                         const timeToSeek = progressData.lastWatchedTime;
                         const lastUpdatedTimestamp = progressData.lastUpdated; // ISO format

                         if (player && player.seekTo) { // Check if player is ready
                             player.seekTo(timeToSeek); // Resume video
                             console.log('Resuming video to:', timeToSeek, 'seconds');

                              const minutes = Math.floor(timeToSeek / 60);
                              const seconds = Math.floor(timeToSeek % 60);
                              const timestamp = lastUpdatedTimestamp ? new Date(lastUpdatedTimestamp).toLocaleString() : 'unknown date';

                              showMessage(resumeMessageElement, `Resuming from ${minutes}m ${seconds}s (Last viewed: ${timestamp})`, 'info');
                              // Hide message after a few seconds
                              setTimeout(() => { clearMessage(resumeMessageElement); }, 8000);
                         } else {
                             console.log("Player not ready yet, cannot resume.");
                             // You might store the timeToSeek globally and seek when player is ready
                              // This requires modifying onPlayerReady
                         }
                     } else {
                         console.log("No valid progress data found to resume from.");
                          // progressData might be empty, completed, or time is 0
                     }

                 } catch (error) {
                     console.error('Error fetching or processing progress data:', error);
                      // showMessage(resumeMessageElement, `An unexpected error occurred while loading progress: ${error.message}`, 'error'); // Optional
                 }
            }


            // --- Function to Save User Video Progress (Current Time) ---
             async function saveProgress(username, topicId, currentTime) {
                 if (!username || !topicId || currentTime === undefined) {
                     console.warn("Cannot save progress: Username, topicId, or current time is missing.");
                     return;
                 }

                 // console.log(`Saving progress for user '${username}', topic_id '${topicId}': ${currentTime}s`); // Avoid excessive logging

                  const saveUrl = `http://127.0.0.1:5000/progress/save/${username}/${topicId}`;
                  const progressData = { currentTime: currentTime };

                  try {
                       const response = await fetch(saveUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(progressData),
                        });

                        if (!response.ok) {
                            console.error('Failed to save progress:', response.status, response.statusText);
                             // Optional: Show error message on the page
                             // showMessage(someElement, `Error saving progress: ${response.statusText}`, 'error');
                        } else {
                             // console.log('Progress saved successfully.'); // Avoid excessive logging
                        }
                   } catch (error) {
                        console.error('Error during save progress fetch:', error);
                         // Optional: Show error message
                   }
             }

            // --- Function to Mark Video as Completed ---
             async function markVideoAsCompleted(username, topicId) {
                 if (!username || !topicId) {
                     console.warn("Cannot mark video as completed: Username or topicId is missing.");
                     return;
                 }
                 console.log(`Marking video ${topicId} as completed for user ${username}.`);

                 const completeUrl = `http://127.0.0.1:5000/progress/complete/${username}/${topicId}`;

                 try {
                      const response = await fetch(completeUrl, {
                           method: 'POST',
                           headers: {
                               'Content-Type': 'application/json',
                           },
                           // No body needed for this endpoint usually
                       });

                       if (!response.ok) {
                           console.error('Failed to mark video as completed:', response.status, response.statusText);
                            // Optional: Show error message on the page
                             // showMessage(someElement, `Error marking completed: ${response.statusText}`, 'error');
                       } else {
                            const successData = await response.json(); // Backend might return a message
                            console.log('Video marked completed successfully:', successData.message);
                            // Optional: Show success message on the page briefly
                       }
                 } catch (error) {
                      console.error('Error during mark completed fetch:', error);
                       // Optional: Show error message
                 }
             }


            // --- YouTube Player API Event Handlers ---

            // The API calls this function when the video player is ready.
            function onPlayerReady(event) {
                 console.log('YouTube Player is ready');
                 // Now that the player is ready, if we had a pending seek time
                 // from fetchAndLoadProgress, we could seek here.
                 // For simplicity, fetchAndLoadProgress now seeks directly if player is ready.

                 // Start saving progress periodically or on state change
                 // We will save progress on state change (play, pause, end)
                 // No need for a continuous timer if saving on state changes.

                 // If the user has a saved progress time from fetchAndLoadProgress
                 // that couldn't be applied because the player wasn't ready,
                 // we could store that time globally and apply it here.
                 // e.g., if (window.pendingSeekTime !== undefined) { event.target.seekTo(window.pendingSeekTime); window.pendingSeekTime = undefined; }
            }

            // The API calls this function when the player's state changes.
            function onPlayerStateChange(event) {
                 // Ensure we have the current video topic ID and user
                 const loggedInUsername = localStorage.getItem(LOGGED_IN_USERNAME_KEY) || sessionStorage.getItem(LOGGED_IN_USERNAME_KEY);
                 if (!loggedInUsername || loggedInUsername === 'Guest' || !currentVideoTopicId) {
                     // Cannot save progress for guests or if video ID is missing
                     return;
                 }

                 // Save video progress (time and timestamp) when playing, paused, or ended
                 if (event.data === YT.PlayerState.PLAYING || event.data === YT.PlayerState.PAUSED) {
                     const currentTime = player.getCurrentTime();
                     // Call the async saveProgress function (don't await inside event handler)
                     saveProgress(loggedInUsername, currentVideoTopicId, currentTime);

                 } else if (event.data === YT.PlayerState.ENDED) {
                     console.log('Video ended.');
                     const currentTime = player.getCurrentTime(); // Get final time (should be close to duration)
                     // Mark this video as completed for the logged-in user
                     markVideoAsCompleted(loggedInUsername, currentVideoTopicId);

                     // Save final time (optional, complete might handle it)
                     saveProgress(loggedInUsername, currentVideoTopicId, currentTime);

                     // Optional: Remove saved progress data from localStorage if using it (we are now using backend)
                     // localStorage.removeItem(VIDEO_PROGRESS_KEY_PREFIX + currentVideoTopicId);
                     // console.log('Removed saved progress from localStorage for ended video.');

                     const resumeMessageElement = document.getElementById('resumeMessage');
                     if (resumeMessageElement) {
                         clearMessage(resumeMessageElement); // Hide resume message
                     }
                 }
                 // Optional: Handle other states like BUFFERING, CUED, etc.
            }


            // --- Event Listener for Note Saving ---
             document.addEventListener('DOMContentLoaded', function() {
                  const notesTextarea = document.getElementById('videoNotes');
                   const loggedInUsername = localStorage.getItem(LOGGED_IN_USERNAME_KEY) || sessionStorage.getItem(LOGGED_IN_USERNAME_KEY);

                   // Note: The note saving logic needs to know the current video ID.
                   // The 'input' listener is attached when DOM is ready, but needs to wait for video details to be fetched.
                   // Let's add the event listener inside fetchVideoAndLoadPlayer after currentVideoTopicId is set.
                   // OR, add the listener here, but the saveNotes function checks for currentVideoTopicId and username.

                   // Attaching listener here, saveNotes function handles validation
                   if (notesTextarea) {
                       let saveNotesTimer = null;
                       notesTextarea.addEventListener('input', function() {
                            // Clear previous timer
                           clearTimeout(saveNotesTimer);
                           // Set a new timer to save after a delay (user stops typing)
                           saveNotesTimer = setTimeout(() => {
                                const noteContent = notesTextarea.value;
                                 // Call the async saveNotes function (don't await inside event handler)
                                saveNotes(loggedInUsername, currentVideoTopicId, noteContent);
                           }, 1000); // Save 1 second after user stops typing
                       });
                   }


                   // --- Handle Logout Click ---
                   const logoutBtnElement = document.getElementById('logoutBtn');
                   if (logoutBtnElement) {
                       logoutBtnElement.addEventListener('click', function(e) {
                           e.preventDefault();
                           console.log("Logging out...");
                           localStorage.removeItem('userAuthenticated');
                           sessionStorage.removeItem('userAuthenticated');
                           localStorage.removeItem('adminAuthenticated');
                           localStorage.removeItem('loggedInUsername');
                           sessionStorage.removeItem('loggedInUsername');

                           window.location.replace("auth.html");
                       });
                   }

                   // --- Initial Page Load Logic (Catalog vs Player) ---
                    const urlParams = new URLSearchParams(window.location.search);
                    const videoTopicIdInUrl = urlParams.get('video');

                    const courseIndexContent = document.getElementById('courseIndexContent');
                    const videoPlayerContent = document.getElementById('videoPlayerContent');
                    const pageTitle = document.getElementById('pageTitle');
                    const indexLoadingMessage = document.getElementById('indexLoadingMessage');


                    if (videoTopicIdInUrl) {
                        // If a video ID is present in the URL
                        console.log(`Video ID "${videoTopicIdInUrl}" found in URL. Switching to player view.`);
                        // We wait for onYouTubeIframeAPIReady to call fetchVideoAndLoadPlayer

                        // Set initial display state while waiting for API/fetch
                        if (courseIndexContent) courseIndexContent.classList.add('hidden');
                        if (videoPlayerContent) videoPlayerContent.classList.remove('hidden');
                         if (pageTitle) pageTitle.textContent = "Loading Video...";
                         if (indexLoadingMessage) indexLoadingMessage.style.display = 'none'; // Hide catalog loading


                    } else {
                        // If no video ID in URL, display the course index
                        console.log("No video ID in URL. Displaying course catalog.");
                         if (pageTitle) pageTitle.textContent = "Course Catalog";
                         if (videoPlayerContent) videoPlayerContent.classList.add('hidden'); // Ensure player is hidden
                         if (courseIndexContent) courseIndexContent.classList.remove('hidden'); // Ensure index is visible

                        // Fetch all videos and render the index
                         fetchAllVideosAndRenderIndex();
                    }

             }); // End of DOMContentLoaded


            // --- Function to Fetch All Videos and Render the Course Index ---
            async function fetchAllVideosAndRenderIndex() {
                const courseIndexContentDiv = document.getElementById('courseIndexContent');
                 const indexLoadingMessageElement = document.getElementById('indexLoadingMessage');
                 if (!courseIndexContentDiv || !indexLoadingMessageElement) return;

                 clearMessage(indexLoadingMessageElement); // Clear previous content
                 showMessage(indexLoadingMessageElement, "Loading course catalog...", 'info'); // Show loading message

                 console.log("Fetching all videos from backend for catalog.");

                 try {
                     const response = await fetch(`http://127.0.0.1:5000/courses/all`);
                     if (!response.ok) {
                         console.error('Failed to fetch all videos:', response.status, response.statusText);
                          showMessage(indexLoadingMessageElement, `Error loading courses: ${response.statusText}`, 'error');
                         return; // Stop if fetch fails
                     }
                     const videosData = await response.json();
                     console.log('All videos data fetched:', videosData);

                     clearMessage(indexLoadingMessageElement); // Clear loading message

                     if (!Array.isArray(videosData) || videosData.length === 0) {
                          showMessage(courseIndexContentDiv, 'No courses or videos available yet. Admin needs to add them.', 'secondary');
                          console.log("No video data received or data is not an array.");
                          return;
                     }

                     // --- Render the Course Index from Fetched Video Data ---
                     renderCourseIndex(videosData);


                 } catch (error) {
                     console.error('Error fetching or processing all videos data:', error);
                      showMessage(indexLoadingMessageElement, `An unexpected error occurred while loading courses: ${error.message}`, 'error');
                 }
             }

             // --- Function to Render the Course Index from Video Data Array ---
             function renderCourseIndex(videosData) {
                  const courseIndexContentDiv = document.getElementById('courseIndexContent');
                  if (!courseIndexContentDiv) return;

                 courseIndexContentDiv.innerHTML = ''; // Clear current content area

                 if (videosData.length === 0) {
                     // This case is already handled by fetchAllVideosAndRenderIndex, but as a fallback
                      showMessage(courseIndexContentDiv, 'No courses or videos available to render.', 'secondary');
                     return;
                 }

                 // Group videos by module/track
                 const modules = {};
                 videosData.forEach(video => {
                      // Ensure videoModule exists, use a default if not
                      const moduleName = video.videoModule || 'Uncategorized';
                      if (!modules[moduleName]) {
                           modules[moduleName] = [];
                       }
                       modules[moduleName].push(video);
                   });

                 // Get module titles and symbols (You might want to store these in DB/backend)
                  const moduleTitles = {
                       'Statistics': 'ðŸ“Š Statistics Fundamentals',
                       'Excel': 'ðŸ“ˆ Excel for Data Analysis',
                       'SQL': 'ðŸ—„ï¸ SQL for Analytics',
                      'data-analyst': 'ðŸŸ¦ MODULE 1: Data Analyst Track', // Include previous examples
                      'business-analyst': 'ðŸŸ¨ MODULE 2: Business Analyst Track',
                      'data-scientist': 'ðŸŸ¥ MODULE 3: Data Scientist Track',
                      'big-data': 'ðŸŸ© BONUS MODULE: Big Data & Cloud Tools',
                      'Uncategorized': 'â“ Uncategorized Videos', // Handle uncategorized
                   };

                 // Render modules and topics
                 const moduleKeys = Object.keys(modules).sort(); // Sort modules alphabetically

                 if (moduleKeys.length === 0) {
                      // Should not happen if videosData is not empty and all have modules, but as a fallback
                      showMessage(courseIndexContentDiv, 'No course modules defined in data. Videos might be missing module names.', 'secondary');
                      return;
                   }


                 moduleKeys.forEach(moduleKey => {
                     const moduleVideos = modules[moduleKey];
                      // Sort videos within the module by video title
                     moduleVideos.sort((a, b) => a.videoTitle.localeCompare(b.videoTitle));

                     const moduleSection = document.createElement('section');
                     moduleSection.classList.add('course-module');

                     // Use the full module title from the map, fallback to moduleKey
                      const fullModuleTitle = moduleTitles[moduleKey] || `ðŸ“š ${moduleKey}`;


                     moduleSection.innerHTML = `
                         <h2>${fullModuleTitle}</h2>
                         <p class="module-goal">Browse videos in this module.</p> <div class="topic-list-grid">
                         </div>
                     `;

                     const topicListGrid = moduleSection.querySelector('.topic-list-grid');

                     moduleVideos.forEach(video => {
                         const topicCardLink = document.createElement('a');
                         topicCardLink.href = `courses.html?video=${video.topicId}`; // Link to the video player view
                         topicCardLink.classList.add('topic-card');

                         topicCardLink.innerHTML = `
                             <h4>${video.videoTitle}</h4>
                             <p>${video.videoDescription || 'No description available.'}</p>
                             <span class="view-video-link"><i class="fas fa-video"></i> Watch ${video.videoUrl && video.videoUrl.includes('list=') ? 'Playlist' : 'Video'}</span> `;
                         topicListGrid.appendChild(topicCardLink);
                     });

                     courseIndexContentDiv.appendChild(moduleSection);
                 });

                 // Add the coming soon message at the end
                 const comingSoonMessage = document.createElement('p');
                 comingSoonMessage.classList.add('coming-soon');
                 comingSoonMessage.textContent = 'ðŸš§ More categories and videos coming soon...';
                 courseIndexContentDiv.appendChild(comingSoonMessage);

             }


        </script>

    </body>
    </html>