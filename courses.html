<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Courses - Ukno Club</title>
    <link rel="stylesheet" href="courses.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Roboto&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="course-container">
        <header class="course-header">
            <div class="branding">
                <img src="assets/logo.png" alt="Ukno Club" class="logo">
                <h1 id="pageTitle">Loading...</h1> </div>
            <nav class="header-nav">
                <a href="dashboard.html">Dashboard</a>
                 <a href="notes.html">My Notes</a>
                <a href="feedback.html">Feedback</a>
                 <a href="auth.html" class="logout-btn" id="logoutBtn">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </a>
            </nav>
        </header>

        <main class="course-main">
            <div id="courseIndexContent">
                 <p id="indexLoadingMessage" class="message-info">Loading course catalog...</p>
                 </div>

            <div id="videoPlayerContent" class="hidden">
                <div class="back-link-container">
                    <a href="courses.html" class="back-link"><i class="fas fa-arrow-left"></i> Back to Catalog</a>
                </div>
                <h2 id="videoTitle"></h2> <div class="video-notes-layout">
                    <div class="video-player-section">
                         <div id="youtubePlayer"></div>
                         <p id="resumeMessage" class="message" style="display: none;"></p>
                          <div id="playlistItemsContainer" class="hidden">
                               <h4>Playlist Videos:</h4>
                               <ul id="playlistItemsList">
                                   </ul>
                          </div>
                    </div>
                    <div class="notes-section">
                        <h3>Your Notes</h3>
                        <label for="videoNotes"></label>
                        <textarea id="videoNotes" placeholder="Write your notes here..."></textarea>
                         <p id="notesMessage" class="message"></p>
                    </div>
                </div>

            </div>
        </main>

        <script>
            // --- localStorage/sessionStorage Keys (Consistent) ---
            const ADMIN_AUTH_KEY = 'adminAuthenticated';
            const LOGGED_IN_USERNAME_KEY = 'loggedInUsername';


            // --- Authentication Check ---
             const userAuthLocal = localStorage.getItem('userAuthenticated') === 'true';
             const userAuthSession = sessionStorage.getItem('userAuthenticated') === 'true';
             const adminAuthLocal = localStorage.getItem(ADMIN_AUTH_KEY) === 'true';

             console.log("--- Courses.html Auth Check ---");
             console.log("localStorage userAuthenticated:", localStorage.getItem('userAuthenticated'), "->", userAuthLocal);
             console.log("sessionStorage userAuthenticated:", sessionStorage.getItem('userAuthenticated'), "->", userAuthSession);
             console.log("localStorage adminAuthenticated:", localStorage.getItem(ADMIN_AUTH_KEY), "->", adminAuthLocal);


             if (!userAuthLocal && !userAuthSession && !adminAuthLocal) {
                 console.log("Courses: User is NOT authenticated. Redirecting to auth.html");
                 window.location.replace("auth.html#login");
                 throw new Error("Not Authenticated");
             } else {
                  console.log("Courses: User IS authenticated. Proceeding to load courses content.");
             }


            // --- YouTube Player API Script ---
            var tag = document.createElement('script');
             tag.src = "https://www.youtube.com/iframe_api"; // Standard YouTube API URL
            var firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);


            // --- Global variables for YouTube Player and Current Video ---
            var player;
            let currentVideoTopicId = null;
            let currentVideoDbId = null;


            // --- Helper Function to show messages in a specific element ---
            function showMessage(element, message, type = 'info') {
                if (element) {
                    element.textContent = message;
                    element.className = `message message-${type}`;
                     element.style.display = 'block';
                }
            }

            function clearMessage(element) {
                 if (element) {
                     element.textContent = '';
                     element.className = 'message';
                     element.style.display = 'none';
                 }
            }

             // --- Helper function to format seconds into HH:MM:SS ---
             function formatTimeToHHMMSS(totalSeconds) {
                if (isNaN(totalSeconds) || totalSeconds < 0) return '00:00:00';
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = Math.floor(totalSeconds % 60);

                const paddedHours = hours < 10 ? '0' + hours : hours;
                const paddedMinutes = minutes < 10 ? '0' + minutes : minutes;
                const paddedSeconds = seconds < 10 ? '0' + seconds : seconds;

                return hours > 0 ? `${paddedHours}:${paddedMinutes}:${paddedSeconds}` : `${paddedMinutes}:${paddedSeconds}`;
             }


            // --- Function called when the YouTube API is ready. ---
            function onYouTubeIframeAPIReady() {
                console.log('YouTube IFrame API is ready');
                 const urlParams = new URLSearchParams(window.location.search);
                 const videoTopicIdInUrl = urlParams.get('video');

                 // Wait for DOM to be fully loaded before proceeding with initial render
                 document.addEventListener('DOMContentLoaded', function() {
                      if (videoTopicIdInUrl) {
                           fetchVideoAndLoadPlayer(videoTopicIdInUrl);
                      } else {
                           console.log("No video ID in URL, DOMContentLoaded will handle catalog.");
                           // Ensure catalog is rendered if DOM is already loaded before API ready
                           if (document.getElementById('courseIndexContent') && !document.getElementById('courseIndexContent').classList.contains('hidden')) {
                                // If catalog is already visible, fetch and render it
                                fetchAllVideosAndRenderIndex();
                           }
                      }
                 });

            }

            // --- Function to Fetch a Specific Video's Data and Load the Player ---
            async function fetchVideoAndLoadPlayer(topicId) {
                const videoTitleElement = document.getElementById('videoTitle');
                 const videoPlayerContentDiv = document.getElementById('videoPlayerContent');
                 const courseIndexContentDiv = document.getElementById('courseIndexContent');
                 const pageTitleElement = document.getElementById('pageTitle');
                 const indexLoadingMessage = document.getElementById('indexLoadingMessage');


                 if (courseIndexContentDiv) courseIndexContentDiv.classList.add('hidden');
                 if (videoPlayerContentDiv) videoPlayerContentDiv.classList.remove('hidden');
                 if (indexLoadingMessage) indexLoadingMessage.style.display = 'none';


                if (videoTitleElement) videoTitleElement.textContent = "Loading Video...";
                if (pageTitleElement) pageTitleElement.textContent = "Loading Video...";

                console.log('Attempting to fetch video details for topicId:', topicId);

                try {
                     const response = await fetch(`http://127.0.0.1:5000/courses/video/${topicId}`);
                     if (!response.ok) {
                         console.error('Failed to fetch video details:', response.status, response.statusText);
                          if (videoTitleElement) videoTitleElement.textContent = "Error Loading Video";
                          if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                           if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Error loading video details.</p>';
                         return;
                     }
                     const videoDetails = await response.json();
                     console.log('Video details fetched:', videoDetails);

                     if (!videoDetails || !videoDetails.topicId || !videoDetails.videoUrl) {
                          console.error('Fetched video data is incomplete or invalid:', videoDetails);
                           if (videoTitleElement) videoTitleElement.textContent = "Error Loading Video";
                           if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                           if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Fetched video data is incomplete.</p>';
                          return;
                     }

                     currentVideoTopicId = videoDetails.topicId;
                     currentVideoDbId = videoDetails.id;

                     if (videoTitleElement) videoTitleElement.textContent = videoDetails.videoTitle;
                     if (pageTitleElement) pageTitleElement.textContent = videoDetails.videoTitle;


                     let youtubeId = null;
                     let isPlaylist = false;

                      try {
                           const url = new URL(videoDetails.videoUrl);
                           // Check for standard YouTube domains (youtube.com, youtu.be, youtu.be)
                           if (url.hostname.includes('youtube.com') || url.hostname.includes('youtu.be')) {
                                if (url.searchParams.get('list')) {
                                    isPlaylist = true;
                                    youtubeId = url.searchParams.get('list');
                                     console.log('Detected YouTube playlist ID:', youtubeId);
                                } else if (url.searchParams.get('v')) {
                                    youtubeId = url.searchParams.get('v');
                                     console.log('Detected YouTube video ID from v parameter:', youtubeId);
                                } else if (url.hostname === 'youtu.be') {
                                     const pathSegments = url.pathname.split('/').filter(segment => segment);
                                     if (pathSegments.length > 0) {
                                          youtubeId = pathSegments[0];
                                           console.log('Detected YouTube video ID from youtu.be path:', youtubeId);
                                     }
                                } else {
                                     // Handle /embed/ or other path formats if necessary
                                     const pathSegments = url.pathname.split('/').filter(segment => segment);
                                      if (pathSegments.length > 1 && pathSegments[0] === 'embed') {
                                          youtubeId = pathSegments[1];
                                          console.log('Detected YouTube video ID from /embed/ path:', youtubeId);
                                      } else if (pathSegments.length > 0) {
                                          // Fallback: Assume last path segment is video ID if other methods fail
                                           youtubeId = pathSegments[pathSegments.length - 1];
                                           console.log('Detected YouTube video ID from last path segment (fallback):', youtubeId);
                                      }
                                }
                           } else {
                                console.warn("Video URL does not appear to be a standard YouTube URL:", videoDetails.videoUrl);
                           }
                      } catch (e) {
                          console.error("Error parsing video URL:", videoDetails.videoUrl, e);
                           if (videoTitleElement) videoTitleElement.textContent = "Invalid Video URL Format";
                           if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                           if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">The video URL format is invalid.</p>';
                          return;
                     }


                     if (!youtubeId) {
                         console.error('Could not extract YouTube ID from URL:', videoDetails.videoUrl);
                          if (videoTitleElement) videoTitleElement.textContent = "Invalid Video URL";
                          if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                          if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = '<p class="message message-error">Could not extract YouTube video/playlist ID from the URL.</p>';
                         return;
                     }


                     // --- Load the YouTube Player ---
                      const youtubePlayerDiv = document.getElementById('youtubePlayer');
                     if (typeof YT !== 'undefined' && YT.Player && youtubePlayerDiv) {
                          const playerOptions = {
                              height: '390',
                              width: '100%', // Use 100% width and let CSS container handle responsive
                              playerVars: {
                                  'autoplay': 1,
                                  'controls': 1,
                                  'enablejsapi': 1,
                                  'rel': 0,
                                  'showinfo': 0,
                                  'modestbranding': 1,
                                  'playsinline': 1
                              },
                              events: {
                                  'onReady': onPlayerReady,
                                  'onStateChange': onPlayerStateChange,
                              }
                          };

                          if (isPlaylist) {
                              playerOptions.playerVars.listType = 'playlist';
                              playerOptions.playerVars.list = youtubeId;
                               console.log("Loading YouTube Playlist with ID:", youtubeId);
                               const playlistItemsContainer = document.getElementById('playlistItemsContainer');
                               if (playlistItemsContainer) playlistItemsContainer.classList.remove('hidden');
                               // TODO: Fetch playlist items from YouTube Data API and populate #playlistItemsList
                               console.warn("Playlist item listing is not yet implemented (requires YouTube Data API).");

                          } else {
                              playerOptions.videoId = youtubeId;
                               console.log("Loading YouTube Video with ID:", youtubeId);
                               const playlistItemsContainer = document.getElementById('playlistItemsContainer');
                               if (playlistItemsContainer) playlistItemsContainer.classList.add('hidden');
                          }

                           youtubePlayerDiv.innerHTML = '';

                          player = new YT.Player('youtubePlayer', playerOptions);
                          console.log("YouTube Player initiated.");

                      } else {
                            console.error("YouTube API not ready or 'youtubePlayer' element not found!");
                             if (videoPlayerContentDiv) {
                                  videoPlayerContentDiv.innerHTML = '<p class="message message-error">Error initializing video player (API not loaded or HTML element missing).</p>';
                                   if (videoTitleElement) videoTitleElement.textContent = "Player Error";
                                   if (pageTitleElement) pageTitleElement.textContent = "Player Error";
                             }
                      }


                    // --- Fetch and Load Saved Notes ---
                    const loggedInUsername = localStorage.getItem(LOGGED_IN_USERNAME_KEY) || sessionStorage.getItem(LOGGED_IN_USERNAME_KEY);
                    fetchAndLoadNotes(loggedInUsername, currentVideoTopicId);


                    // --- Fetch and Load Saved Progress ---
                     fetchAndLoadProgress(loggedInUsername, currentVideoTopicId);


                 } catch (error) {
                     console.error('An unexpected error occurred while fetching video details:', error);
                      if (videoTitleElement) videoTitleElement.textContent = "Error Loading Video";
                      if (pageTitleElement) pageTitleElement.textContent = "Video Error";
                      if (videoPlayerContentDiv) videoPlayerContentDiv.innerHTML = `<p class="message message-error">An unexpected error occurred: ${error.message}</p>`;
                 }
            }

            // --- Function to Fetch and Load Saved Notes ---
            async function fetchAndLoadNotes(username, topicId) {
                 const notesTextarea = document.getElementById('videoNotes');
                 const notesMessageElement = document.getElementById('notesMessage');
                 if (!notesTextarea || !notesMessageElement) return;

                 if (!username || !topicId) {
                     console.warn("Cannot fetch notes: Username or topicId is missing.");
                     return;
                 }

                 clearMessage(notesMessageElement);
                 showMessage(notesMessageElement, "Loading notes...", 'info');

                 console.log(`Workspaceing notes for user '${username}' and topic_id '${topicId}'`);

                 try {
                     const response = await fetch(`http://127.0.0.1:5000/notes/${username}/${topicId}`);
                     if (!response.ok) {
                         console.error('Failed to fetch notes:', response.status, response.statusText);
                          showMessage(notesMessageElement, `Error loading notes: ${response.statusText}`, 'error');
                         return;
                     }
                     const notesData = await response.json();
                     console.log('Notes data fetched:', notesData);

                     clearMessage(notesMessageElement);

                     if (notesData && notesData.noteContent !== undefined) {
                          notesTextarea.value = notesData.noteContent;
                          console.log("Notes textarea populated.");
                     } else {
                          notesTextarea.value = '';
                          console.log("No note found for this video.");
                     }

                 } catch (error) {
                     console.error('Error fetching or processing notes data:', error);
                      showMessage(notesMessageElement, `An unexpected error occurred while loading notes: ${error.message}`, 'error');
                 }
            }

            // --- Function to Save Notes ---
             async function saveNotes(username, topicId, noteContent) {
                 const notesMessageElement = document.getElementById('notesMessage');
                  if (!notesMessageElement) return;

                 if (!username || !topicId) {
                     console.warn("Cannot save notes: Username or topicId is missing.");
                      showMessage(notesMessageElement, "Login required to save notes.", 'secondary');
                     return;
                 }

                 console.log(`Attempting to save notes for user '${username}' and topic_id '${topicId}'`);

                 try {
                      const response = await fetch(`http://127.0.0.1:5000/notes/save/${username}/${topicId}`, {
                           method: 'POST',
                           headers: {
                               'Content-Type': 'application/json',
                           },
                           body: JSON.stringify({ noteContent: noteContent }),
                       });

                       if (!response.ok) {
                            console.error('Failed to save notes:', response.status, response.statusText);
                           const errorData = await response.json().catch(() => ({ message: `Error saving notes: ${response.statusText}` }));
                           showMessage(notesMessageElement, errorData.message, 'error');
                            return;
                       }

                       const successData = await response.json();
                       console.log('Notes save success:', successData);
                       showMessage(notesMessageElement, successData.message || 'Notes saved!', 'success');


                       setTimeout(() => { clearMessage(notesMessageElement); }, 2000);

                 } catch (error) {
                      console.error('Error during notes save fetch:', error);
                       showMessage(notesMessageElement, `Error saving notes: ${error.message}`, 'error');
                 }
             }


            // --- Function to Fetch and Load Saved Progress ---
             async function fetchAndLoadProgress(username, topicId) {
                 const resumeMessageElement = document.getElementById('resumeMessage');
                 if (!resumeMessageElement) return;

                 if (!username || !topicId) {
                     console.warn("Cannot fetch progress: Username or topicId is missing.");
                     return;
                 }

                 console.log(`Workspaceing progress for user '${username}' and topic_id '${topicId}'`);

                 try {
                     const response = await fetch(`http://127.0.0.1:5000/progress/${username}/${topicId}`);
                     if (response.status === 404) {
                         console.log(`No existing progress found for ${username} / ${topicId} (404).`);
                         return;
                     }
                     if (!response.ok) {
                          console.error('Backend progress fetch failed with unexpected status:', response.status, response.statusText);
                         return;
                     }
                     const progressData = await response.json();
                     console.log('Progress data fetched:', progressData);

                     if (progressData && progressData.lastWatchedTime !== undefined && progressData.lastWatchedTime > 0 && !progressData.completed) {
                         const timeToSeek = progressData.lastWatchedTime;
                         const lastUpdatedTimestamp = progressData.lastUpdated;

                          function seekWhenReady() {
                               if (player && typeof player.seekTo === 'function') {
                                   player.seekTo(timeToSeek);
                                   console.log('Resuming video to:', timeToSeek, 'seconds after player ready');

                                    const minutes = Math.floor(timeToSeek / 60);
                                    const seconds = Math.floor(timeToSeek % 60);
                                    const timestamp = lastUpdatedTimestamp ? new Date(lastUpdatedTimestamp).toLocaleString() : 'unknown date';

                                    showMessage(resumeMessageElement, `Resuming from ${minutes}m ${seconds}s (Last viewed: ${timestamp})`, 'info');
                                    setTimeout(() => { clearMessage(resumeMessageElement); }, 8000);
                               } else {
                                   console.log("Player not yet ready for seeking, waiting...");
                                    setTimeout(seekWhenReady, 100);
                               }
                           }

                          seekWhenReady();


                     } else {
                         console.log("No valid progress data found to resume from, or video already completed.");
                     }

                 } catch (error) {
                     console.error('Error fetching or processing progress data:', error);
                 }
            }


            // --- Function to Save User Video Progress (Current Time) ---
             async function saveProgress(username, topicId, currentTime) {
                 if (!username || !topicId || currentTime === undefined) {
                     console.warn("Cannot save progress: Username, topicId, or current time is missing.");
                     return;
                 }

                  const saveUrl = `http://127.0.0.1:5000/progress/save/${username}/${topicId}`;
                  const progressData = { currentTime: currentTime };

                  try {
                       const response = await fetch(saveUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                           },
                           body: JSON.stringify(progressData),
                       });

                       if (!response.ok) {
                           console.error('Failed to save progress:', response.status, response.statusText);
                       } else {
                            // console.log('Progress saved successfully.');
                       }
                   } catch (error) {
                       console.error('Error during save progress fetch:', error);
                   }
             }

            // --- Function to Mark Video as Completed ---
             async function markVideoAsCompleted(username, topicId) {
                 if (!username || !topicId) {
                     console.warn("Cannot mark video as completed: Username or topicId is missing.");
                     return;
                 }
                 console.log(`Marking video ${topicId} as completed for user ${username}.`);

                 const completeUrl = `http://127.0.0.0/progress/complete/${username}/${topicId}`;

                 try {
                      const response = await fetch(completeUrl, {
                           method: 'POST',
                           headers: {
                               'Content-Type': 'application/json',
                           },
                       });

                       if (!response.ok) {
                           console.error('Failed to mark video as completed:', response.status, response.statusText);
                       } else {
                            const successData = await response.json().catch(() => ({ message: 'Completed successfully (no message from backend)'}));
                            console.log('Video marked completed successfully:', successData.message);
                       }
                 } catch (error) {
                      console.error('Error during mark completed fetch:', error);
                 }
             }


            // --- YouTube Player API Event Handlers ---

            function onPlayerReady(event) {
                 console.log('YouTube Player is ready');
            }

            function onPlayerStateChange(event) {
                 const loggedInUsername = localStorage.getItem(LOGGED_IN_USERNAME_KEY) || sessionStorage.getItem(LOGGED_IN_USERNAME_KEY);
                 if (!loggedInUsername || loggedInUsername === 'Guest' || !currentVideoTopicId) {
                     return;
                 }

                 if (event.data === YT.PlayerState.PLAYING || event.data === YT.PlayerState.PAUSED) {
                     const currentTime = player.getCurrentTime();
                      if (window.saveProgressTimer) {
                           clearTimeout(window.saveProgressTimer);
                       }
                       window.saveProgressTimer = setTimeout(() => {
                            saveProgress(loggedInUsername, currentVideoTopicId, currentTime);
                       }, 2000);


                 } else if (event.data === YT.PlayerState.ENDED) {
                     console.log('Video ended.');
                     if (window.saveProgressTimer) {
                          clearTimeout(window.saveProgressTimer);
                      }
                     const currentTime = player.getCurrentTime();
                     markVideoAsCompleted(loggedInUsername, currentVideoTopicId);
                     saveProgress(loggedInUsername, currentVideoTopicId, currentTime);


                     const resumeMessageElement = document.getElementById('resumeMessage');
                     if (resumeMessageElement) {
                         clearMessage(resumeMessageElement);
                     }
                 }
            }


            // --- Event Listener for Note Saving (Auto-save while typing & on blur) ---
             document.addEventListener('DOMContentLoaded', function() {
                  const notesTextarea = document.getElementById('videoNotes');
                   const loggedInUsername = localStorage.getItem(LOGGED_IN_USERNAME_KEY) || sessionStorage.getItem(LOGGED_IN_USERNAME_KEY);

                   if (notesTextarea) {
                       let saveNotesTimer = null;
                       notesTextarea.addEventListener('input', function() {
                           clearTimeout(saveNotesTimer);
                           saveNotesTimer = setTimeout(() => {
                                const noteContent = notesTextarea.value;
                                 if (currentVideoTopicId) {
                                      saveNotes(loggedInUsername, currentVideoTopicId, noteContent);
                                 } else {
                                      console.warn("Cannot auto-save notes: Video Topic ID not set.");
                                 }
                           }, 1000);
                       });
                       notesTextarea.addEventListener('blur', function() {
                           clearTimeout(saveNotesTimer);
                           const noteContent = notesTextarea.value;
                            if (currentVideoTopicId) {
                                 saveNotes(loggedInUsername, currentVideoTopicId, noteContent);
                            } else {
                                 console.warn("Cannot save notes on blur: Video Topic ID not set.");
                            }
                       });
                   }


                   // --- Handle Logout Click ---
                   const logoutBtnElement = document.getElementById('logoutBtn');
                   if (logoutBtnElement) {
                       logoutBtnElement.addEventListener('click', function(e) {
                           e.preventDefault();
                           console.log("Logging out...");
                           localStorage.removeItem('userAuthenticated');
                           sessionStorage.removeItem('userAuthenticated');
                           localStorage.removeItem('adminAuthenticated');
                           localStorage.removeItem('loggedInUsername');
                           sessionStorage.removeItem('loggedInUsername');

                           window.location.replace("auth.html");
                       });
                   }

                   // --- Initial Page Load Logic (Catalog vs Player) ---
                    const urlParams = new URLSearchParams(window.location.search);
                    const videoTopicIdInUrl = urlParams.get('video');

                    const courseIndexContent = document.getElementById('courseIndexContent');
                    const videoPlayerContent = document.getElementById('videoPlayerContent');
                    const pageTitle = document.getElementById('pageTitle');
                    const indexLoadingMessage = document.getElementById('indexLoadingMessage');


                    if (videoTopicIdInUrl) {
                        console.log(`Video ID "${videoTopicIdInUrl}" found in URL. Switching to player view.`);
                        if (courseIndexContent) courseIndexContent.classList.add('hidden');
                        if (videoPlayerContent) videoPlayerContent.classList.remove('hidden');
                         if (pageTitle) pageTitle.textContent = "Loading Video...";
                         if (indexLoadingMessage) indexLoadingMessage.style.display = 'none';


                    } else {
                        console.log("No video ID in URL. Displaying course catalog.");
                         if (pageTitle) pageTitle.textContent = "Course Catalog";
                         if (videoPlayerContent) videoPlayerContent.classList.add('hidden');
                         if (courseIndexContent) courseIndexContent.classList.remove('hidden');

                        // Fetch all videos and render the index
                         fetchAllVideosAndRenderIndex();
                    }

             }); // End of DOMContentLoaded


            // --- Function to Fetch All Videos and Render the Course Index (Heading + Grid Below) ---
            async function fetchAllVideosAndRenderIndex() {
                const courseIndexContentDiv = document.getElementById('courseIndexContent');
                 const indexLoadingMessageElement = document.getElementById('indexLoadingMessage');
                 if (!courseIndexContentDiv || !indexLoadingMessageElement) return;

                 clearMessage(indexLoadingMessageElement);
                 showMessage(indexLoadingMessageElement, "Loading course catalog...", 'info');

                 console.log("Fetching all videos from backend for catalog.");

                 try {
                     const response = await fetch(`http://127.0.0.1:5000/courses/all`);
                     if (!response.ok) {
                         console.error('Failed to fetch all videos:', response.status, response.statusText);
                          showMessage(indexLoadingMessageElement, `Error loading courses: ${response.statusText}`, 'error');
                         return;
                     }
                     const videosData = await response.json();
                     console.log('All videos data fetched:', videosData);

                     clearMessage(indexLoadingMessageElement);

                     if (!Array.isArray(videosData) || videosData.length === 0) {
                          showMessage(courseIndexContentDiv, 'No courses or videos available yet. Admin needs to add them.', 'secondary');
                          console.log("No video data received or data is not an array.");
                          return;
                     }

                     renderCourseIndex(videosData);


                 } catch (error) {
                     console.error('Error fetching or processing all videos data:', error);
                      showMessage(indexLoadingMessageElement, `An unexpected error occurred while loading courses: ${error.message}`, 'error');
                 }
             }

             // --- Function to Render the Course Index from Video Data Array (Heading + Grid Below Layout) ---
             function renderCourseIndex(videosData) {
                  const courseIndexContentDiv = document.getElementById('courseIndexContent');
                  if (!courseIndexContentDiv) return;

                 courseIndexContentDiv.innerHTML = '';

                 if (videosData.length === 0) {
                      showMessage(courseIndexContentDiv, 'No courses or videos available to render.', 'secondary');
                     return;
                 }

                 // Group videos by module/track
                 const modules = {};
                 videosData.forEach(video => {
                      const moduleName = video.videoModule || 'Uncategorized';
                      if (!modules[moduleName]) {
                           modules[moduleName] = [];
                       }
                       modules[moduleName].push(video);
                   });

                  // Define display titles and goals for modules/tracks based on your provided content structure
                  // The keys here should match the videoModule values you add in the admin panel
                  const moduleDisplayInfo = {
                       'data-analyst': { title: 'ðŸŸ¦ MODULE 1: Data Analyst Track', goal: 'Learn tools to analyze and visualize data using spreadsheets, SQL, and BI tools.'},
                       'business-analyst': { title: 'ðŸŸ¨ MODULE 2: Business Analyst Track', goal: 'Learn tools to interpret and present business insights, focusing on decision-making, reporting, and stakeholder communication.'},
                       'data-scientist': { title: 'ðŸŸ¥ MODULE 3: Data Scientist Track', goal: 'Learn modeling, prediction, and advanced data processing using ML and AI.'},
                       'big-data': { title: 'ðŸŸ© BONUS MODULE: Big Data & Cloud Tools', goal: 'Learn to work with massive datasets using scalable tools and platforms.'},
                       // Also include individual topic names if they are used as module names in backend
                        'Statistics': { title: 'STATISTICS'},
                        'Excel': { title: 'EXCEL'},
                        'SQL': { title: 'SQL'},
                        'Power BI': { title: 'POWER BI'},
                        'Tableau': { title: 'TABLEAU'},
                        'Python': { title: 'PYTHON'},
                        'R': { title: 'R'},
                        'SPSS': { title: 'SPSS'},
                        'Business Decision Making': { title: 'BUSINESS DECISION MAKING'},
                        'Machine Learning Basics': { title: 'MACHINE LEARNING BASICS'},
                        'Deep Learning & Neural Networks': { title: 'DEEP LEARNING & NEURAL NETWORKS'},
                        'Artificial Intelligence Concepts': { title: 'ARTIFICIAL INTELLIGENCE CONCEPTS'},
                        'Big Data Tools (Hadoop & Spark)': { title: 'BIG DATA TOOLS (HADOOP & SPARK)'},
                        'Cloud Platforms (AWS, GCP, Azure)': { title: 'CLOUD PLATFORMS (AWS, GCP, AZURE)'},
                       'Uncategorized': { title: 'â“ Uncategorized'}
                   };

                 // Order the modules based on your content structure preference
                 const orderedModuleKeys = [
                     'data-analyst',
                     'business-analyst',
                     'data-scientist',
                     'big-data',
                     // Add individual topics/modules here if they should appear as their own main section
                      'Statistics', 'Excel', 'SQL', 'Power BI', 'Tableau',
                      'Python', 'R', 'SPSS', 'Business Decision Making',
                      'Machine Learning Basics', 'Deep Learning & Neural Networks', 'Artificial Intelligence Concepts',
                       'Big Data Tools (Hadoop & Spark)', 'Cloud Platforms (AWS, GCP, Azure)',
                       'Uncategorized' // Keep uncategorized last
                 ].filter(key => modules[key]); // Filter to only include keys that have videos

                 // Add any remaining module keys that weren't in the ordered list (e.g., new modules)
                 const remainingKeys = Object.keys(modules).filter(key => !orderedModuleKeys.includes(key));
                  orderedModuleKeys.push(...remainingKeys.sort());


                 if (orderedModuleKeys.length === 0) {
                      showMessage(courseIndexContentDiv, 'No course modules defined in data. Videos might be missing module names.', 'secondary');
                      return;
                   }

                 // Optional: Add a main heading for the entire catalog section if desired
                 // const mainCatalogHeading = document.createElement('h2');
                 // mainCatalogHeading.classList.add('main-catalog-heading');
                 // mainCatalogHeading.textContent = 'Course Catalog'; // Or 'Available Tracks/Courses'
                 // courseIndexContentDiv.appendChild(mainCatalogHeading);


                 orderedModuleKeys.forEach(moduleKey => {
                     const moduleVideos = modules[moduleKey];
                     moduleVideos.sort((a, b) => a.videoTitle.localeCompare(b.videoTitle)); // Sort videos alphabetically within module

                     // Create a section for each module (containing heading and grid)
                     const moduleSection = document.createElement('section');
                     moduleSection.classList.add('module-section'); // Container for module heading and grid

                     const displayInfo = moduleDisplayInfo[moduleKey] || { title: moduleKey, goal: '' };

                     // Add the module heading
                     const moduleHeading = document.createElement('h2');
                     moduleHeading.classList.add('module-heading'); // Class for the module heading
                     moduleHeading.textContent = displayInfo.title;
                     moduleSection.appendChild(moduleHeading);

                     // Add the module goal/description if available
                     if (displayInfo.goal) {
                         const moduleGoal = document.createElement('p');
                         moduleGoal.classList.add('module-goal');
                         moduleGoal.textContent = `Goal: ${displayInfo.goal}`;
                         moduleSection.appendChild(moduleGoal);
                     }


                     // Create the grid container *below* the module heading for topic cards
                     const topicCardsGrid = document.createElement('div');
                     topicCardsGrid.classList.add('topic-cards-grid'); // Class for the grid *below* the heading

                     moduleVideos.forEach(video => {
                         const topicCardLink = document.createElement('a');
                         topicCardLink.href = `courses.html?video=${video.topicId}`; // Link to the video player view
                         topicCardLink.classList.add('topic-card'); // Class for the smaller clickable topic card

                          // Card content based on screenshot (Title) and backend data (description)
                         topicCardLink.innerHTML = `
                             <h4>${video.videoTitle.toUpperCase()}</h4> <p class="topic-card-details">${video.videoDescription || 'Some details'}</p> `;
                         topicCardsGrid.appendChild(topicCardLink); // Append to the grid below the heading
                     });

                     moduleSection.appendChild(topicCardsGrid); // Append the grid to the module section

                     courseIndexContentDiv.appendChild(moduleSection); // Append the module section (heading + grid) to the main content div

                 });

                 const comingSoonMessage = document.createElement('p');
                 comingSoonMessage.classList.add('coming-soon');
                 comingSoonMessage.textContent = 'ðŸš§ More categories and videos coming soon...';
                 courseIndexContentDiv.appendChild(comingSoonMessage);

             }


        </script>

    </body>
    </html>